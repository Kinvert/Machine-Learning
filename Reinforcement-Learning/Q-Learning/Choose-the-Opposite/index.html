<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Q-Learning Button Game</title>
    <style>
        body {
            background-color: #121212;
            color: #e0e0e0;
            font-family: Arial, sans-serif;
        }
        .game-button {
            background-color: #333;
            color: #fff;
            border: 1px solid #555;
            transition: background-color 0.2s;
        }
        .game-button:hover {
            background-color: #555;
        }
        #q-space {
            display: grid;
            gap: 5px;
            margin-top: 20px;
        }
        .q-cell {
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: white;
        }
        #stats {
            margin-top: 20px;
            font-family: monospace;
        }
        .button-grid {
            display: grid;
            gap: 5px;
            margin-top: 20px;
        }
        .game-button {
            width: 50px;
            height: 50px;
            background-color: #eee;
        }
        .filled {
            background-color: #666;
        }
    </style>
</head>
<body>
    <h1>Q-Learning Button Game</h1>
    <p>Training the AI to select empty buttons after a random initialization</p>
    <p>To initialize a random button is clicked</p>
    <p>To win the agent must click each unoccupied button once</p>
    <div class="button-grid" id="buttons"></div>
    <div id="stats"></div>
    <div id="q-space"></div>
    <script>
        const NUM_ACTIONS = 3; // Number of buttons
        const alpha = 0.25;  // Learning rate
        const gamma = 0.9;  // Discount factor
        let epsilon = 0.25; // Exploration rate

        // Generate all possible states with one button filled
        function generateInitialStates() {
            return Array.from({length: NUM_ACTIONS}, (_, i) => {
                const state = Array(NUM_ACTIONS).fill('0');
                state[i] = '1';
                return state.join('');
            });
        }

        // Generate all possible states with two buttons filled
        function generateIntermediateStates() {
            const states = [];
            for (let i = 0; i < NUM_ACTIONS; i++) {
                for (let j = i + 1; j < NUM_ACTIONS; j++) {
                    const state = Array(NUM_ACTIONS).fill('0');
                    state[i] = '1';
                    state[j] = '1';
                    states.push(state.join(''));
                }
            }
            return states;
        }

        const INITIAL_STATES = generateInitialStates();
        const INTERMEDIATE_STATES = generateIntermediateStates();

        // Initialize Q-table
        let qTable = {};
        [...INITIAL_STATES, ...INTERMEDIATE_STATES].forEach(state => {
            qTable[state] = new Array(NUM_ACTIONS).fill(0);
        });

        function getAction(state, explore = true) {
            if (explore && Math.random() < epsilon) {
                return Math.floor(Math.random() * NUM_ACTIONS); // Explore
            }
            return qTable[state].indexOf(Math.max(...qTable[state])); // Exploit
        }

        function updateQTable(state, action, reward, nextState) {
            // Q(s,a) = (1-α)Q(s,a) + α(R + γ*max(Q(s')))
            const oldQ = qTable[state][action];
            const nextMaxQ = nextState ? Math.max(...qTable[nextState]) : 0;
            qTable[state][action] = (1 - alpha) * oldQ + alpha * (reward + gamma * nextMaxQ);
        }

        function visualizeQSpace() {
            const qSpace = document.getElementById('q-space');
            qSpace.innerHTML = '';
            qSpace.style.gridTemplateColumns = `repeat(${NUM_ACTIONS}, 50px)`;

            [...INITIAL_STATES, ...INTERMEDIATE_STATES].forEach(state => {
                qTable[state].forEach(value => {
                    const cell = document.createElement('div');
                    cell.className = 'q-cell';
                    const normalizedValue = (value + 1) / 2;
                    const red = Math.floor((1 - normalizedValue) * 255);
                    const green = Math.floor(normalizedValue * 255);
                    cell.style.backgroundColor = `rgb(${red}, ${green}, 0)`;
                    cell.textContent = value.toFixed(2);
                    qSpace.appendChild(cell);
                });
            });
        }

        function initializeButtons() {
            const buttonGrid = document.getElementById('buttons');
            buttonGrid.style.gridTemplateColumns = `repeat(${NUM_ACTIONS}, 50px)`;
            for (let i = 0; i < NUM_ACTIONS; i++) {
                const button = document.createElement('button');
                button.className = 'game-button';
                button.id = `button-${i}`;
                button.textContent = i;
                buttonGrid.appendChild(button);
            }
        }

        function train(numGames = NUM_GAMES) {
            let gamesInWindow = 0;
            let winsInWindow = 0;
            let totalGames = 0;
            let totalWins = 0;

            for (let game = 1; game <= numGames; game++) {
                totalGames++;
                gamesInWindow++;
                
                // Random initial state
                const initialStateIndex = Math.floor(Math.random() * INITIAL_STATES.length);
                let currentState = INITIAL_STATES[initialStateIndex];
                let moves = [];
                let won = true;

                // Make NUM_ACTIONS-1 moves
                for (let step = 0; step < NUM_ACTIONS - 1; step++) {
                    const action = getAction(currentState);
                    moves.push(action);
                    
                    if (currentState[action] === '1') {
                        // Invalid move
                        updateQTable(currentState, action, -1, null);
                        won = false;
                        break;
                    }

                    // Make move
                    const stateArray = currentState.split('');
                    stateArray[action] = '1';
                    const nextState = stateArray.join('');

                    if (step === NUM_ACTIONS - 2) {
                        // Final move
                        updateQTable(currentState, action, won ? 1 : -1, null);
                    } else {
                        // Intermediate move
                        updateQTable(currentState, action, 0, nextState);
                        currentState = nextState;
                    }
                }

                if (won) {
                    winsInWindow++;
                    totalWins++;
                }

                // Show results every 10 games up to 100, then every 100
                if (game < 10 || game <= 100 && game % 10 === 0 || game > 100 && game % 100 === 0) {
                    const winRate = (totalWins / totalGames) * 100;
                    let gameStr = game.toString().padStart(3, '0');
                    document.getElementById('stats').innerHTML += 
                        `Game ${gameStr}: Win rate: ${winRate.toFixed(1)}%, Init: ${initialStateIndex}, ` +
                        `Moves: [${moves.join(', ')}]<br>`;
                    
                    if (game % 100 === 0) {
                        winsInWindow = 0;
                        gamesInWindow = 0;
                        visualizeQSpace();
                    }
                }
            }
        }

        // Train
        initializeButtons();
        visualizeQSpace();
        train(100);

        // Test
        epsilon = 0.00;
        document.getElementById('stats').innerHTML += `<br>DONE TRAINING - SETTING EPSILON TO ZERO<br><br>`;
        train(100);
    </script>
</body>
</html>